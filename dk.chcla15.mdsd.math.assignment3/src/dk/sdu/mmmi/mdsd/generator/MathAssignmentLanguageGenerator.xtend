/*
 * generated by Xtext 2.21.0
 */
package dk.sdu.mmmi.mdsd.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import javax.swing.JOptionPane
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.MathExp
import java.util.HashMap
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Expression
import java.util.Map
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Plus
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Minus
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Mult
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Div
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Num
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Var
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Let
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.ResultStatement
import java.util.HashSet
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.ExternalDef
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.ExternalUse

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathAssignmentLanguageGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		val math = resource.allContents.filter(MathExp).next // Root level of metamodel instance
		//val results = math.compute
		//System.out.println("Math expressions = \n" + math.display)
		//JOptionPane.showMessageDialog(null, results.prettyPrint,"Math Language", JOptionPane.INFORMATION_MESSAGE)
		
		fsa.generateFile("MathComputation.java", math.compile)		
		
		fsa.generateFile("compileAndRun.sh", 
			'''
			#!/bin/bash
			javac MathComputation.java
			java MathComputation
			'''
		)
		
		
		//val math = resource.allContents.filter(MathExp).next
		//val result = math.compute
		//System.out.println("Math expression = "+math.display)
		//JOptionPane.showMessageDialog(null, "result = "+result,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
	def compile(MathExp math) {
		// Name of the generated class
		val className = "MathComputation"
		val externalDefs = math.declarations.filter(ExternalDef)
		val resultStatements = math.declarations.filter(ResultStatement)		
		
		'''
		/*
		* -- AUTO-GENERATED CODE --
		* --   DO NOT MODIFY!    --
		*/
		public class «className» {
			
			/*
			* Fields
			*/
			«IF externalDefs.length > 0»
			private Externals externals;
			«ENDIF»
			
			/*
			* Constructors
			*/
			«IF externalDefs.length > 0»
			public «className»(Externals externals) {
				this.externals = externals;
			}
			
			/*
			* External functions
			*/
			public static interface Externals {
				«FOR externalDef : externalDefs»
				«generateExternalSignature(externalDef)»
				«ENDFOR»
			}
			«ELSE»
			public «className»() { }
			«ENDIF»
			
			
			/*
			* Public methods
			*/
			public void compute() {
				// Call compute on each result-statement
				«FOR resultStatement : resultStatements»
				System.out.println("«resultStatement.label» " + compute«resultStatement.label.convertTolegalJavaIdentifier.toFirstUpper»());
				«ENDFOR»
			}
			
			/*
			* Result statements
			*/
			«FOR resultStatement : resultStatements»
				«generatePrivateMethod(resultStatement)»
			«ENDFOR»
			
			/*
			* Main methods
			*/
			public static void main(String[] args) {
				new «className»().compute();
			}
		}
		'''
	}
	
	def String generateExternalSignature(ExternalDef exDef) {
		val parameters = exDef.parameters
		
		val parameterString = new StringBuilder()
		for (parameter : parameters) {
			if (parameterString.length > 0) parameterString.append(", ")
			parameterString.append(parameter.type.name).append(" ").append(parameter.parameterName)
		}
		
		return
		'''
		public int «exDef.name»(«parameterString»);
		'''
	}
	
	def String generatePrivateMethod(ResultStatement r) {
		'''
		private int compute«r.label.convertTolegalJavaIdentifier.toFirstUpper»() {
			return «r.exp.compile(new HashMap<String, Integer>)»;
		}
		'''
	}
	
	def String convertTolegalJavaIdentifier(String s) {
		val validChars = "[a-z]|[A-Z]|\\d|[_]"
		val illegalChars = new HashSet()
		
		var validIdentifier = new String(s)
		
		// Find illegal chars
		for (var i = 0; i < s.length(); i++) {
			val myChar = s.substring(i, i+1);
			if (!myChar.matches(validChars)) {
				illegalChars.add(myChar);
			}
		}
		
		// Remove illegal chars
		for (String illegalChar : illegalChars) {
			validIdentifier = validIdentifier.replace(illegalChar, "");
		}
		
		return validIdentifier
	}
	
	def String compile(Expression exp, Map<String,Integer> env) {
		switch (exp) {
			Plus: '''«exp.left.computeExp(env)»+«exp.right.computeExp(env)»'''
			Minus: '''«exp.left.computeExp(env)»-«exp.right.computeExp(env)»'''
			Mult: '''«exp.left.computeExp(env)»*«exp.right.computeExp(env)»'''
			Div: '''«exp.left.computeExp(env)»/«exp.right.computeExp(env)»'''
			Num: '''«exp.value»'''
			Var: '''«env.get(exp.id)»'''
			//Let: exp.body.computeExp(env.bind(exp.id,exp.binding.computeExp(env)))
			ExternalUse: {
				val extArguments = new StringBuilder()
				for (extExp : exp.arguments) {
					if (extArguments.length > 0) extArguments.append(", ")
					extArguments.append("(").append(extExp.compile(env)).append(")")
				}
			 	'''externals.«exp.external.name»(«extArguments»)'''
			 }
			
			default: throw new Error("Compile: Invalid expression")
		}
	}
	
	def compute(MathExp math) {
		val results = new HashMap<ResultStatement, Integer>
		
		math.declarations.filter(ResultStatement).forEach[ r | {
			results.put(r, r.exp.computeExp(new HashMap<String, Integer>))
		}]
		
		return results
	}
	
	def prettyPrint(HashMap<ResultStatement, Integer> map) {
		val displayStrings = new StringBuilder
		
		map.forEach[r, i| {
			displayStrings.append("result \"" + r.label + "\" is " +
				i + "\n"
			)
		}]
		
		return displayStrings.toString
	}
	
	def display(MathExp math) {
		val displayStrings = new StringBuilder
		
		math.declarations.filter(ResultStatement).forEach[ r | {
			displayStrings.append(r.exp.displayExp() + "\n"
			)
		}]
		
		return displayStrings.toString
	}
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	//def int compute(MathExp math) {
	//	math.exp.computeExp(new HashMap<String,Integer>)
	//}
	
	def int computeExp(Expression exp, Map<String,Integer> env) {
		switch exp {
			Plus: exp.left.computeExp(env)+exp.right.computeExp(env)
			Minus: exp.left.computeExp(env)-exp.right.computeExp(env)
			Mult: exp.left.computeExp(env)*exp.right.computeExp(env)
			Div: exp.left.computeExp(env)/exp.right.computeExp(env)
			Num: exp.value
			Var: env.get(exp.id)
			Let: exp.body.computeExp(env.bind(exp.id,exp.binding.computeExp(env)))
			default: throw new Error("Compute: Invalid expression")
		}
	}
	
	def Map<String, Integer> bind(Map<String, Integer> env1, String name, int value) {
		val env2 = new HashMap<String,Integer>(env1)
		env2.put(name,value)
		env2 
	}

	//
	// Display function: show complete syntax tree
	// Note: written according to illegal left-recursive grammar, requires fix
	//

	//def String display(MathExp math) { 
	//	math.exp.displayExp
	//}

	
	def String displayExp(Expression exp) {
		"("+switch exp {
			Plus: exp.left.displayExp+"+"+exp.right.displayExp
			Minus: exp.left.displayExp+"-"+exp.right.displayExp
			Mult: exp.left.displayExp+"*"+exp.right.displayExp
			Div: exp.left.displayExp+"/"+exp.right.displayExp
			Num: Integer.toString(exp.value)
			Var: exp.id
			Let: '''let «exp.id» = «exp.binding.displayExp» in «exp.body.displayExp» end'''
			default: throw new Error("Invalid expression")
		}+")"
	}
}
