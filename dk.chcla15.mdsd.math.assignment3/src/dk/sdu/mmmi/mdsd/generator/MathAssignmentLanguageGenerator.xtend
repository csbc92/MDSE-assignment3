/*
 * generated by Xtext 2.21.0
 */
package dk.sdu.mmmi.mdsd.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.MathExp
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Expression
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Plus
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Minus
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Mult
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Div
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Num
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Var
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Let
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.ResultStatement
import java.util.HashSet
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.ExternalDef
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.ExternalUse

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathAssignmentLanguageGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		val math = resource.allContents.filter(MathExp).next // Root level of metamodel instance
		
		fsa.generateFile("MathComputation.java", math.compile)		
		
		fsa.generateFile("compileAndRun.sh", 
			'''
			#!/bin/bash
			javac MathComputation.java
			java MathComputation
			'''
		)
	}
	
	def compile(MathExp math) {
		val className = "MathComputation" // Name of the generated class
		val externalDefs = math.declarations.filter(ExternalDef)
		val resultStatements = math.declarations.filter(ResultStatement)		
		
		'''
		/*
		* AUTO-GENERATED CODE!
		*/
		
		/*
		* Imports
		*/
		import java.util.function.Function;
		
		/*
		* Class
		*/
		public class «className» {
			
			/*
			* Fields
			*/
			«IF externalDefs.length > 0»
			private Externals externals;
			«ENDIF»
			
			/*
			* Constructors
			*/
			«IF externalDefs.length > 0»
			public «className»(Externals externals) {
				this.externals = externals;
			}
			
			/*
			* External functions
			*/
			public static interface Externals {
				«FOR externalDef : externalDefs»
				«generateExternalSignature(externalDef)»;
				«ENDFOR»
			}
			«ELSE»
			public «className»() { }
			«ENDIF»
			
			
			/*
			* Public methods
			*/
			public void compute() {
				// Call compute on each result-statement
				«FOR resultStatement : resultStatements»
				System.out.println("«resultStatement.label» " + compute«resultStatement.label.convertTolegalJavaIdentifier.toFirstUpper»());
				«ENDFOR»
			}
			
			/*
			* Result statements
			*/
			«FOR resultStatement : resultStatements»
				«generatePrivateMethod(resultStatement)»
			«ENDFOR»
			
			/*
			* Main methods
			*/
			«IF externalDefs.length > 0»
			public static void main(String[] args) {
				new «className»(new Externals() {
					@Override
					«FOR externalDef : externalDefs»
					«generateExternalSignature(externalDef)» {
						// TODO: Implement method
						throw new UnsupportedOperationException();
					}
					«ENDFOR»
				}).compute();
			}
			«ELSE»
			public static void main(String[] args) {
				new «className»().compute();
			}
			«ENDIF»
		}
		'''
	}
	
	def String generateExternalSignature(ExternalDef exDef) {
		val parameters = exDef.parameters
		
		val parameterString = new StringBuilder()
		for (parameter : parameters) {
			if (parameterString.length > 0) parameterString.append(", ")
			parameterString.append(parameter.type.name).append(" ").append(parameter.parameterName)
		}
		
		return
		'''public int «exDef.name»(«parameterString»)'''
	}
	
	def String generatePrivateMethod(ResultStatement r) {
		'''
		private int compute«r.label.convertTolegalJavaIdentifier.toFirstUpper»() {
			return «r.exp.compile»;
		}
		'''
	}
	
	def String convertTolegalJavaIdentifier(String s) {
		val validChars = "[a-z]|[A-Z]|\\d|[_]"
		val illegalChars = new HashSet()
		
		var validIdentifier = new String(s)
		
		// Find illegal chars
		for (var i = 0; i < s.length(); i++) {
			val myChar = s.substring(i, i+1);
			if (!myChar.matches(validChars)) {
				illegalChars.add(myChar);
			}
		}
		
		// Remove illegal chars
		for (String illegalChar : illegalChars) {
			validIdentifier = validIdentifier.replace(illegalChar, "");
		}
		
		return validIdentifier
	}
	
	def String compile(Expression exp) {
		"(" + switch (exp) {
			Plus: '''«exp.left.compile»+«exp.right.compile»'''
			Minus: '''«exp.left.compile»-«exp.right.compile»'''
			Mult: '''«exp.left.compile»*«exp.right.compile»'''
			Div: '''«exp.left.compile»/«exp.right.compile»'''
			Num: '''«exp.value»'''
			Var: '''«exp.id»''' // id is the variable used by the generated java-code for let expressions below
			Let: {
				'''
				new Function<Integer, Integer>() {
					@Override
					public Integer apply(Integer «exp.id») {
						return «exp.body.compile»;
					}
				}.apply(«exp.binding.compile»)'''
			}
			ExternalUse: {
				val extArguments = new StringBuilder()
				for (extExp : exp.arguments) {
					if (extArguments.length > 0) extArguments.append(", ")
					extArguments.append("(").append(extExp.compile).append(")")
				}
			 	'''externals.«exp.external.name»(«extArguments»)'''
			 }
			
			default: throw new Error("Compile: Invalid expression")
		} + ")"
	}
}
